<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/graphics.css">
	<title>剑灵</title>
</head>

<body>
	<!-- 头部区域 -->
	<header class="header">
		<h1><a href="" class="logo" title="点击打开剑灵官方网站"></a></h1>
		<nav class="nav">
			<a href="javascript:void(0)" class="nav_t nav_t_cur">资料大全</a>
			<i class="nav_arrow"></i>
			<a href="../版本专题/index.html" class="nav_t">版本专题</a>
			<i class="nav_arrow"></i>
			<a href="../剑灵引导页和客服/service.html" class="nav_t">客服</a>
		</nav>
	</header>

	<!-- 头部区域结束 -->

	<!-- bnner图片1 -->
	<div class="container"></div>
	<div id="jsi-cherry-container" class="banner2 w1176"></div>
	<!-- bnner图片2 -->

	<!-- 系统区域 -->
	<div class="dr-tips">
		<div class="con-main w1176">
			<div class="con-t">
				<h1>重要系统介绍</h1>
				<div class="hr"></div>
				<ul class="tips-list fix">
					<li>
						<div class="tips-box">
							<img src="images/os_img_01.jpg" alt="">
							<div class="tips-txt">跨服副本</div>
							<a href="" class="a01">点击了解 ></a>
						</div>
					</li>
					<li>
						<div class="tips-box">
							<img src="images/os_img_03.jpg" alt="">
							<div class="tips-txt">采集制作</div>
							<a href="" class="a01">点击了解 ></a>
						</div>
					</li>
					<li class="no-mr">
						<div class="tips-box">
							<img src="images/os_img_05.jpg" alt="">
							<div class="tips-txt">修炼</div>
							<a href="" class="a01">点击了解 ></a>
						</div>
					</li>
				</ul>
			</div>
		</div>
	</div>
	<!-- 职业区域 -->
	<div class="dr-tyd">
		<div class="con-main">
			<div class="con-t ">
				<h1>职业</h1>
				<div class="hr"></div>
				<div class="p01">剑士的剑法变幻莫测，可以格挡或反制敌人的攻击，

					<br>
					也能应付远距离的敌人，
					是可以应付所有情况的最佳职业。
				</div>
			</div>
			<div class="carousel-content">
				<!-- 左右箭头 -->
				<div class="arrow">
					<span class="left">&lt;</span>
					<span class="right">&gt;</span>
				</div>
				<ul class="carousel clearfix">
					<li class="swiper-wrapper clearfix">
						<div class="swiper-img">
							<img src="images/download1.png" alt="">
						</div>
						<div class="co">
							<div class="c-box">
								<div class="p01">剑士</div>
								<div class="p02">
									核心思想便是“一击必杀”，<br>
									具有超强爆发力，利用瞬间高<br>
									速的拔刀攻击对敌人造成毁灭<br>
									控制剑进行远程战斗的技巧，<br>
									最多可同时控制6把剑。<br>
									基础的战斗姿态，注重攻守平<br>
									衡性，善于格挡敌人的攻击。<br>
									在剑士的华丽剑式上加以强<br>
									化，高伤害，高爆发，如行云<br>
									流水般爽快。
								</div>
								<div class="p03">BLADE MASTER</div>
								<a href="" class="a02">职业介绍</a>
								<div class="pro-box">
									<img src="images/pf_1_1.png" alt="">
								</div>
							</div>
						</div>
					</li>
					<li class="swiper-wrapper clearfix">
						<div class="swiper-img">
							<img src="images/download3.png" alt="">
						</div>
						<div class="co">
							<div class="c-box">
								<div class="p01">枪手</div>
								<div class="p02">
									枪手使用枪械与立体机动装置，<br>
									有独一无二的战斗方式。<br>
									枪手可用双枪进行超密集火力输出，<br>
									也可用步枪远距离一击必杀。<br>
									天月石让枪手实现了立体机动作战，<br>
									是一个高频输出的高机动职业。<br>
									使用天空石枪手可实现独一无二的立体机动作战<br>
									枪手洪门奥义：<br>
									超远程狙击，一击必杀！<br>
									通过右键技能积攒热负荷。在达到临界的瞬间，超密集火力爆发！
								</div>
								<div class="p03">Shooter</div>
								<a href="" class="a02">职业介绍</a>
								<div class="pro-box">
									<img src="images/img001.webp" alt="">
								</div>
							</div>
						</div>
					</li>
					<li class="swiper-wrapper clearfix">
						<div class="swiper-img">
							<img src="images/download4.png" alt="">
						</div>
						<div class="co">
							<div class="c-box">
								<div class="p01">气宗</div>
								<div class="p02">
									气宗运用带有气功之力的拳法，<br>
									施展各种武功招式。<br>
									气宗可以通过转换态势灵活对战远近不同的敌人，<br>
									即可积攒内功对敌人发动攻击，<br>
									也可对队友施展保护<br>
									使用转换姿态技能，<br>
									可在气击/拳击姿态中自由切换<br>
									可使用冰系气击技能，<br>
									操纵寒霜之力给对手带来毁灭性打击。<br>
									大地系拳击武技可以近身给对手造成天崩地裂般的伤害。
								</div>
								<div class="p03">Soulfighter</div>
								<a href="" class="a02">职业介绍</a>
								<div class="pro-box">
									<img src="images/sht001.webp" alt="">
								</div>
							</div>
						</div>
					</li>
				</ul>
				<div class="sw-pagination">
					<div class="pagination">
						<ol></ol>
					</div>
				</div>

				<div class="c-b">
					<a href="" class="a03">体验更多职业</a>
					<br>
					<a href="" class="a04">查看更多职业></a>
				</div>
			</div>
		</div>
		<!-- 战斗区域-->
		<div class="dr-pick">
			<div class="con-main">
				<div class="con-t">
					<h1>战斗</h1>
					<div class="hr"></div>
				</div>
				<div class="sw-container">
					<div class="wrapper1 sw-cn-wrapper">
						<div class="sw-slide-img">
							<a href="" class=""><img src="images/ca1.png" alt=""></a>
						</div>
						<div class="sw-slide-img">
							<a href="" class=""><img src="images/ca2.png"></a>
						</div>
						<div class="sw-slide-img">
							<a href="" class=""><img src="images/ca3.png" alt=""></a>
						</div>
						<div class="sw-slide-img">
							<a href="" class=""><img src="images/ca4.png" alt=""></a>
						</div>
					</div>
				</div>
				<div class="sw-cn-wz">
					<div class="sw-wz-box">
						<div class="sw-wz-box02">
							<div class="pro-co">
								<div class="p05">设计理念</div>
								<div class="p06">
									【体验服】5月18日例行更新维护公告<br>
									【正式服】5月17日例行更新维护公告<br>
									【正式服】5月11日例行更新维护公告<br>
									新春福利礼包 开启完美仙侠之旅<br>
									跨界合作年节赠礼 免费机票送你回家
								</div>
							</div>
						</div>
						<div class="sw-wz-box02">
							<div class="pro-co">
								<div class="p05">设计理念</div>
								<div class="p06">
									媒体焚香现世资料片新手礼包合集<br>
									【97973】隐藏任务奇遇任务汇总<br>
									官方桌面版上线 部分正式服抢先体验<br>
									一周重点活动盘点（11月17日-11月23日）<br>
								</div>
							</div>
						</div>
						<div class="sw-wz-box02">
							<div class="pro-co">
								<div class="p05">设计理念</div>
								<div class="p06">
									传说雪花是落入凡间的小精灵<br>
									能实现女人浪漫的爱情梦想<br>
									此款钻戒以雪花作为灵感<br>
									只为世间纯粹真爱的浪漫表达<br>
									雪花般纯粹的浪漫，只为一人实现<br>
								</div>
							</div>
						</div>
						<div class="sw-wz-box02">
							<div class="pro-co">
								<div class="p05">设计理念</div>
								<div class="p06">
									焚香是与世无争的虔诚信徒<br>
									通过收集仙友们反馈的意见和建议<br>
									具有代表性且对游戏有积极意义<br>
									献策将会在诛仙大陆得以实现<br>
									并在此公告天下<br>
								</div>
							</div>
						</div>
					</div>
				</div>
				<div class="sw-container">
					<div class="wrapper2 sw-cn-wrapper">
						<div class="sw-slide-img">
							<a href="" class=""><img src="images/ch1.png" alt=""></a>
							<span class="ic"></span>
							<div class="info-box">
								<div class="p01">My Heart系列 浪漫款</div>
								<div class="hr2"></div>
								<div class="p10">把心交给你</div>
								<div class="p11">进一步了解更多 &gt;</div>
							</div>
						</div>
						<div class="sw-slide-img">
							<a href="" class=""><img src="images/ch2.png" alt=""></a>
							<span class="ic"></span>
							<div class="info-box">
								<div class="p01">Forever系列 经典款</div>
								<div class="hr2"></div>
								<div class="p10">时光流逝，爱你如初</div>
								<div class="p11">进一步了解更多 &gt;</div>
							</div>
						</div>
						<div class="sw-slide-img">
							<a href="" class=""><img src="images/ch3.png" alt=""></a>
							<span class="ic"></span>
							<div class="info-box">
								<div class="p01">Believe系列 经典款</div>
								<div class="hr2"></div>
								<div class="p10">爱你，是我一生的信仰</div>
								<div class="p11">进一步了解更多 &gt;</div>
							</div>
						</div>
						<div class="sw-slide-img">
							<a href="" class=""><img src="images/ch4.png" alt=""></a>
							<span class="ic"></span>
							<div class="info-box">
								<div class="p01">Princess系列 宠爱</div>
								<div class="hr2"></div>
								<div class="p10">这一生我只宠爱你一人</div>
								<div class="p11">进一步了解更多 &gt;</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>


		<!-- 底部区域 -->
		<footer class="footer">
			<div class="f-box">
				<p>
					<a href="">腾讯互动娱乐</a> |
					<a href="">服务条款</a>|
					<a href="">腾讯游戏隐私保护指引</a> |
					<a href="">广告服务</a> |
					<a href="">腾讯游戏招聘</a> |
					<a href="">腾讯游戏客服</a> |
					<a href="">游戏地图</a> |
					<a href="">成长守护平台</a> |
					<a href="">商务合作</a> |
					<a href="">网站导航</a>
				</p>
				<p class="e">COPYRIGHT © 1998 – 2019 TENCENT. ALL RIGHTS RESERVED.</p>
				<a href="">腾讯公司 版权所有</a>
			</div>
		</footer>

		<!-- 底部区域结束 -->

		<script src="animate.js"></script>
		<script src="jquery-1.12.4.js"></script>

		<!-- 樱花雨 -->
		<script>
			var RENDERER = {
				INIT_CHERRY_BLOSSOM_COUNT: 30,
				MAX_ADDING_INTERVAL: 10,

				init: function () {
					this.setParameters();
					this.reconstructMethods();
					this.createCherries();
					this.render();
				},
				setParameters: function () {
					this.$container = $('#jsi-cherry-container');
					this.width = this.$container.width();
					this.height = this.$container.height();
					this.context = $('<canvas />').attr({
						width: this.width,
						height: this.height
					}).appendTo(this.$container).get(0).getContext('2d');
					this.cherries = [];
					this.maxAddingInterval = Math.round(this.MAX_ADDING_INTERVAL * 1000 / this.width);
					this.addingInterval = this.maxAddingInterval;
				},
				reconstructMethods: function () {
					this.render = this.render.bind(this);
				},
				createCherries: function () {
					for (var i = 0, length = Math.round(this.INIT_CHERRY_BLOSSOM_COUNT * this.width / 1000); i <
						length; i++) {
						this.cherries.push(new CHERRY_BLOSSOM(this, true));
					}
				},
				render: function () {
					requestAnimationFrame(this.render);
					this.context.clearRect(0, 0, this.width, this.height);

					this.cherries.sort(function (cherry1, cherry2) {
						return cherry1.z - cherry2.z;
					});
					for (var i = this.cherries.length - 1; i >= 0; i--) {
						if (!this.cherries[i].render(this.context)) {
							this.cherries.splice(i, 1);
						}
					}
					if (--this.addingInterval == 0) {
						this.addingInterval = this.maxAddingInterval;
						this.cherries.push(new CHERRY_BLOSSOM(this, false));
					}
				}
			};
			var CHERRY_BLOSSOM = function (renderer, isRandom) {
				this.renderer = renderer;
				this.init(isRandom);
			};
			CHERRY_BLOSSOM.prototype = {
				FOCUS_POSITION: 300,
				FAR_LIMIT: 600,
				MAX_RIPPLE_COUNT: 100,
				RIPPLE_RADIUS: 100,
				SURFACE_RATE: 0.5,
				SINK_OFFSET: 20,

				init: function (isRandom) {
					this.x = this.getRandomValue(-this.renderer.width, this.renderer.width);
					this.y = isRandom ? this.getRandomValue(0, this.renderer.height) : this.renderer.height * 1.5;
					this.z = this.getRandomValue(0, this.FAR_LIMIT);
					this.vx = this.getRandomValue(-2, 2);
					this.vy = -2;
					this.theta = this.getRandomValue(0, Math.PI * 2);
					this.phi = this.getRandomValue(0, Math.PI * 2);
					this.psi = 0;
					this.dpsi = this.getRandomValue(Math.PI / 600, Math.PI / 300);
					this.opacity = 0;
					this.endTheta = false;
					this.endPhi = false;
					this.rippleCount = 0;

					var axis = this.getAxis(),
						theta = this.theta + Math.ceil(-(this.y + this.renderer.height * this.SURFACE_RATE) / this.vy) *
						Math.PI / 500;
					theta %= Math.PI * 2;

					this.offsetY = 40 * ((theta <= Math.PI / 2 || theta >= Math.PI * 3 / 2) ? -1 : 1);
					this.thresholdY = this.renderer.height / 2 + this.renderer.height * this.SURFACE_RATE * axis.rate;
					this.entityColor = this.renderer.context.createRadialGradient(0, 40, 0, 0, 40, 80);
					this.entityColor.addColorStop(0, 'hsl(330, 70%, ' + 50 * (0.3 + axis.rate) + '%)');
					this.entityColor.addColorStop(0.05, 'hsl(330, 40%,' + 55 * (0.3 + axis.rate) + '%)');
					this.entityColor.addColorStop(1, 'hsl(330, 20%, ' + 70 * (0.3 + axis.rate) + '%)');
					this.shadowColor = this.renderer.context.createRadialGradient(0, 40, 0, 0, 40, 80);
					this.shadowColor.addColorStop(0, 'hsl(330, 40%, ' + 30 * (0.3 + axis.rate) + '%)');
					this.shadowColor.addColorStop(0.05, 'hsl(330, 40%,' + 30 * (0.3 + axis.rate) + '%)');
					this.shadowColor.addColorStop(1, 'hsl(330, 20%, ' + 40 * (0.3 + axis.rate) + '%)');
				},
				getRandomValue: function (min, max) {
					return min + (max - min) * Math.random();
				},
				getAxis: function () {
					var rate = this.FOCUS_POSITION / (this.z + this.FOCUS_POSITION),
						x = this.renderer.width / 2 + this.x * rate,
						y = this.renderer.height / 2 - this.y * rate;
					return {
						rate: rate,
						x: x,
						y: y
					};
				},
				renderCherry: function (context, axis) {
					context.beginPath();
					context.moveTo(0, 40);
					context.bezierCurveTo(-60, 20, -10, -60, 0, -20);
					context.bezierCurveTo(10, -60, 60, 20, 0, 40);
					context.fill();

					for (var i = -4; i < 4; i++) {
						context.beginPath();
						context.moveTo(0, 40);
						context.quadraticCurveTo(i * 12, 10, i * 4, -24 + Math.abs(i) * 2);
						context.stroke();
					}
				},
				render: function (context) {
					var axis = this.getAxis();

					if (axis.y == this.thresholdY && this.rippleCount < this.MAX_RIPPLE_COUNT) {
						context.save();
						context.lineWidth = 2;
						context.strokeStyle = 'hsla(0, 0%, 100%, ' + (this.MAX_RIPPLE_COUNT - this.rippleCount) / this
							.MAX_RIPPLE_COUNT + ')';
						context.translate(axis.x + this.offsetY * axis.rate * (this.theta <= Math.PI ? -1 : 1), axis.y);
						context.scale(1, 0.3);
						context.beginPath();
						context.arc(0, 0, this.rippleCount / this.MAX_RIPPLE_COUNT * this.RIPPLE_RADIUS * axis.rate, 0,
							Math.PI * 2, false);
						context.stroke();
						context.restore();
						this.rippleCount++;
					}
					if (axis.y < this.thresholdY || (!this.endTheta || !this.endPhi)) {
						if (this.y <= 0) {
							this.opacity = Math.min(this.opacity + 0.01, 1);
						}
						context.save();
						context.globalAlpha = this.opacity;
						context.fillStyle = this.shadowColor;
						context.strokeStyle = 'hsl(330, 30%,' + 40 * (0.3 + axis.rate) + '%)';
						context.translate(axis.x, Math.max(axis.y, this.thresholdY + this.thresholdY - axis.y));
						context.rotate(Math.PI - this.theta);
						context.scale(axis.rate * -Math.sin(this.phi), axis.rate);
						context.translate(0, this.offsetY);
						this.renderCherry(context, axis);
						context.restore();
					}
					context.save();
					context.fillStyle = this.entityColor;
					context.strokeStyle = 'hsl(330, 40%,' + 70 * (0.3 + axis.rate) + '%)';
					context.translate(axis.x, axis.y + Math.abs(this.SINK_OFFSET * Math.sin(this.psi) * axis.rate));
					context.rotate(this.theta);
					context.scale(axis.rate * Math.sin(this.phi), axis.rate);
					context.translate(0, this.offsetY);
					this.renderCherry(context, axis);
					context.restore();

					if (this.y <= -this.renderer.height / 4) {
						if (!this.endTheta) {
							for (var theta = Math.PI / 2, end = Math.PI * 3 / 2; theta <= end; theta += Math.PI) {
								if (this.theta < theta && this.theta + Math.PI / 200 > theta) {
									this.theta = theta;
									this.endTheta = true;
									break;
								}
							}
						}
						if (!this.endPhi) {
							for (var phi = Math.PI / 8, end = Math.PI * 7 / 8; phi <= end; phi += Math.PI * 3 / 4) {
								if (this.phi < phi && this.phi + Math.PI / 200 > phi) {
									this.phi = Math.PI / 8;
									this.endPhi = true;
									break;
								}
							}
						}
					}
					if (!this.endTheta) {
						if (axis.y == this.thresholdY) {
							this.theta += Math.PI / 200 * ((this.theta < Math.PI / 2 || (this.theta >= Math.PI && this
								.theta < Math.PI * 3 / 2)) ? 1 : -1);
						} else {
							this.theta += Math.PI / 500;
						}
						this.theta %= Math.PI * 2;
					}
					if (this.endPhi) {
						if (this.rippleCount == this.MAX_RIPPLE_COUNT) {
							this.psi += this.dpsi;
							this.psi %= Math.PI * 2;
						}
					} else {
						this.phi += Math.PI / ((axis.y == this.thresholdY) ? 200 : 500);
						this.phi %= Math.PI;
					}
					if (this.y <= -this.renderer.height * this.SURFACE_RATE) {
						this.x += 2;
						this.y = -this.renderer.height * this.SURFACE_RATE;
					} else {
						this.x += this.vx;
						this.y += this.vy;
					}
					return this.z > -this.FOCUS_POSITION && this.z < this.FAR_LIMIT && this.x < this.renderer.width *
					1.5;
				}
			};
			$(function () {
				RENDERER.init();
			});
		</script>

		<!-- 呼吸灯 -->
		<script>
			$(function () {
				var $divs1 = $(".wrapper1 div.sw-slide-img");
				var $divs2 = $(".wrapper2 div.sw-slide-img");
				var $divWz = $(".sw-wz-box div.sw-wz-box02");
				$divWz.eq(0).show(0);
				// console.log($divWz);
				// console.log($divs1);
				// console.log($divs2);
				var index = 0;
				setInterval(function () {
					if (index == 3) {
						index = -1;
					}
					index++;
					$divs1.eq(index).fadeIn(800).siblings().fadeOut(800);
					$divs2.eq(index).fadeIn(800).siblings().fadeOut(800);
					$divWz.eq(index).fadeIn(800).siblings().fadeOut(800);
				}, 2000)
			});
		</script>


		<!-- 轮播图 -->
		<script>
			var box = document.querySelector(".carousel-content");
			var ul = box.querySelector('ul');
			var ol = box.querySelector('.sw-pagination .pagination ol');
			var imgs = box.children; // li的个数就是图片的个数
			var imgWidth = box.offsetWidth; // 一张图片的宽度，可以从box上获取
			var leftBtn = box.querySelector('.arrow .left');
			var rightBtn = box.querySelector('.arrow .right');

			var count = 0; // ul当前出去的图片的张数，默认是0，一开始展示的是第一张

			// 功能1：js动态添加小圆点
			//  1. 把ol中的所有的li删除掉了（ol容器留着）
			//  2. 根据图片的个数去循环创建小圆点
			//  3. 把创建的小圆点添加到ol
			//  4. 找到第一个li，添加current类名
			for (var i = 0; i < imgs.length; i++) {
				// 循环一次，创建一个li
				var li = document.createElement('li');

				ol.appendChild(li);
			}
			// 第一种写法：
			/*if(i === 0){
				// 创建的li是第一个li
				li.className = "current";
			}*/

			// 在动态创建小圆点之后，在去获取小圆点
			var points = box.querySelectorAll('ol li');
			// 第二种写法：
			points[0].className = 'current';


			// 功能2. js动态添加最后一张假图片
			// 思路： 把第一张克隆出来，克隆的第一张添加到ul的最后面
			ul.appendChild(ul.firstElementChild.cloneNode(true));


			// 功能3. 实现左右焦点图 + 无缝滚动

			// 左箭头的点击事件  看上一张

			leftBtn.onclick = function () {
				// if满足了，说明当前展示的图片是第一张
				if (count <= 0) {

					// 1. 先瞬间切换到假图片
					// 2. 还要记得修改count的值 8
					count = imgs.length - 1; // 8
					ul.style.left = -count * imgWidth + 'px';
				}
				count--;

				animate(ul, -count * imgWidth);

				// 实现小圆点的功能 -- 排他
				for (var i = 0; i < points.length; i++) {
					points[i].className = '';

					if (count >= imgs.length - 1) {
						// 第一个小圆点亮起来
						points[0].className = 'current';
					} else {
						// count 0 - 7
						points[count].className = 'current';
					}
				}
			}


			// 右箭头的点击事件  看下一张
			rightBtn.onclick = function () {
				// 说明当前展示的是假图片
				// count = -1; // 这样是可以切换到第一张的，但是是倒退着展示第一张的
				if (count >= imgs.length - 1) {
					// 从茶叶切换到第一张图片的
					// 1. 先瞬间移动到第一张
					ul.style.left = 0;
					// 2. 还要记得修改count的值0
					count = 0;

				}
				count++;
				// 让出去的图片增加一张


				animate(ul, -count * imgWidth);
				// 修改ul的left  ==>  - count * 790


				// 实现小圆点的功能 -- 排他
				for (var i = 0; i < points.length; i++) {
					// 复活谁
					// this ==> 箭头

					// 做个判断
					// 如果当前展示的图片是假图片，那么就需要让第一个小圆点亮起来

					// 这样写在展示前面8张的时候，都没有问题，当展示假图片 的时候，会报错
					// points[count].className = "current";

					points[i].className = '';

					//  8
					// 当前展示的图片是假图片
					// 第一个小圆点亮起来
					if (count >= imgs.length - 1) {
						points[0].className = 'current';
					} else {
						// count 0 - 7
						points[count].className = 'current';
					}
				}
			}

			// 功能4：自动播放
			//  自动的切换到下一张，开一个定时器，调用右箭头的点击事件
			var timerId = setInterval(function () {
				rightBtn.onclick();
			}, 1500)

			// 鼠标移入到box上，停止定时器
			box.onmouseover = function () {
				clearInterval(timerId);
			}

			// 鼠标移出的时候，重新开启定时器

			// timerId 前面不要加var && timerId 不能省
			// 否则定时器会bug
			box.onmouseout = function () {
				timerId = setInterval(function () {
					rightBtn.onclick();
				}, 1500)
			}

			// 功能5. 点击小圆点同步切换
			//  1. 找对象（小圆点 points）
			//  2. 注册click
			//  3. 排他小圆点 && 移动ul && 修改count的值（当前小圆点的下标）


			// 存下标
			for (var i = 0; i < points.length; i++) {
				points[i].index = i;

				points[i].onclick = function () {
					for (var i = 0; i < points.length; i++) {
						// 排他小圆点
						points[i].className = '';
					}
					this.className = 'current';

					if (count >= imgs.length - 1) {

						// 点击小圆点的时候，当前展示的已经是假图片
						ul.style.left = 0;
						count = 0;
					}

					// 移动ul
					animate(ul, -this.index * imgWidth);

					// 修改count的值
					// 这一步千万别落下了， 否则图片就不对应了
					count = this.index;
				}


			}
		</script>
</body>

</html>